# dddealer

---

## Domain-Driven Design

Domain-Driven Design (предметно-ориентированное проектирование) — это набор принципов, направленных на упрощение 
разработки и проектирования приложений со сложной предметной областью.
Результатом является создание программных абстракций, которые называются моделью предметной области.

Термин Domain-Driven Design был предложен Эриком Эвансом в книге 
"Domain-Driven Design Tackling Complexity in the Heart of Software".

DDD - это всего лишь список рекомендаций, мы можем использовать их по частям.
Сообщество Go несправедливо игнорирует бенефиты, предлагаемые DDD.

Основная цель DDD - это борьба со сложностью бизнес-процессов и их реализации в коде.
DDD набор подходов, который помогает писать код приложений (сервисов) со сложной предметной областью.

Если нам нужен простой CRUD сервис (которые мы больше стараемся не плодить), то DDD это излишество.
В системах с простой бизнес-логикой DDD излишество, оно только усложнит код.

DDD включает в себя:
- Стратегическое проектирование
- Тактическое проектирование (паттерны)
- Подходы к архитектуре
- Взаимодействие между людьми

### ООП

DDD может использовать сильные стороны ООП, но не подразумевает что язык обязан его поддерживает.

Исторически DDD использовался в Java и C#, это ООП языки, а Go нет.  
Но необязательно быть в ловушке ООП с его инкапсуляцией и наследованием, хотя немного полиморфизма нам пригодиться.
Для того что бы писать красивый код с использованием DDD необязательно писать на Go как на Java.

### Основные понятия 

#### Domain (предметная область)

Проектирование в рамках DDD отталкивается от предметной области.
Предметная область — это сущности и действия реального мира, которые надо смоделировать и автоматизировать 
в нашем приложении.

#### Domain Model (модель предметной области/доменная модель).

Реализованная в коде модель предметной области.

#### Domain Experts

Доменные эксперты, люди понимающие, как работают те бизнес-процессы, которые предстоит моделировать.

Технические специалисты — разработчики, архитекторы, те кто непосредственно занимается реализацией приложения.
Обычно между доменными экспертами и техническими специалистами стена и продукт менеджер.
В идеале они должны постоянно работать напрямую и синхронизироваться в достижении целей.

Доменные эксперты часто опускают очевидные для них детали о которых разработчик никогда не подумает.
Технические специалисты должны вытащить из доменных экспертов следующие:
- Знание о модели. Задаем много дополнительных вопросов, прорабатываем каждое действие и аспект, которые станут методами и полями.
- Общие и частные случаи
- Отсечь лишнее, не реализовываем ту часть предметной области, которая не нужна нашей модели
- Обращать внимание на детали

### Strategic Design.

Стратегическое проектирование. Это не про код. 
Технические специалисты вместе с доменными экспертами анализируем Domain.
Определяют Bounded Context, сферу ответственности сервисов и способы их взаимодействия.
Для стратегического проектирования язык и подход к разработке вообще не важен.

Domain - глобальная предметная область, которой бизнес зарабатывает деньги.
Domain - классифайд.

Subdomain - части предметной области, обладающие сильной связанностью, которые на более крупном уровне между собой взаимодействуют.
Часто Subdomain в контексте проекта сокращают просто до Domain, потому что глобально видеть бизнес всей компании нам не так уж и надо.
Subdomain - доставка

С точки зрения DDD Subdomain делятся на 3 типа
- Core - конкурентное преимущество компании, то на чем она зарабатывает деньги, то чем она отличается от конкурентов.
  Для нас это доска объявлений с возможностью покупать разные айтемы.
- Supporting - тоже то что используется для зарабатывания денег, но не то без чего нельзя.
  На Supporting бросается меньше сил, чем на Core, но он все равно очень важен.
  Для нас это доставка. Классифайд может существовать без доставки, но это будет не так удобно, выгодно и безопасно.
- Generic - типовая бизнес-задача, которую можно автоматизировать готовыми продуктами, не требует самостоятельной реализации, лучше использовать 3rd-party решение.
  Для нас это например ведение бухгалтерии в 1c, мы не будем писать для Авито свою систему учета.

Bounded Context - находится рядом с domain.
Subdomain - кусочек бизнеса, кусочек реального мира. Понятие пространства постановки задачи.
Bounded context - контекст, который ограничивает доменную модель и ubiquitous language. Понятия пространства решения.
В процессе разработки происходит маппинг Subdomain на Bounded Context.
Например ребята из логистики придумали как сделать пикап для мерчантов маркетплейса, а для нас это стало сервисом marketplace registry и proxy-api
Доставка -> Custom Applications

Как выбрать правильный размер Bounded Context?
Bounded Context должен быть таким, что бы ubiquitous language был полным и однозначным.
1 Bounded Context = 1 Subdomain
1 Bounded Context = 1 Microservice (На самом деле они будут уже не микро, но это даже хорошо, нам не нужно еще 100 CRUD-сервисов)

Если мы хотим делать совсем каноничные микросервисы, то это скорее всего будет
1 Aggregate = 1 Microservice (Количество связей между сервисами увеличивается)

Один домен мапиться на один контекст, но это идеальная ситуация, необязательно должно быть так.

Нормально, что в одном сервисе несколько агрегатов, например мы работаем с заказами и с ивентами.

### Ubiquitous Language

Общение между участниками проекта формирует Общий язык (Ubiquitous Language).
Набор терминов, применяемый в модели предметной области для ее описания.
Все участники проекта общаются на нем. Обсуждения происходят только в терминах единого языка.
Все артефакты от ТЗ и задач до кода только в терминах единого языка.

Выбираем один английский термин для одного объекта или события бизнес-логики.
Многие ошибки происходят именно из-за плохого перевода или его разночтений.
Многозначных терминов в бизнес-логике лучше избегать: транзакция, политика, запрос.

Контроль единого языка на ревью.

В коде фигурируют человеческие слова и понятная терминология, в теории его может прочесть даже менеджер.
Новые участники команды смогут проще вникать в суть бизнес-процессов.
Сервисы единообразны, просты для понимания

1. Берем сценарий на автоматизацию
2. Строим доменную модель

### Bounded Context

Доменная модель не может быть безграничной и охватывать все.
Тогда она станет размытой и потеряет фокус.

Domain Model и Ubiquitous Language ограничены контекстом (Bounded Context).
Ограничивает доменную модель таким образом, что бы все понятия в нем были однозначными и все участники проекта понимали,
о чем идет речь. У каждого понятия понятная роль и понятное значение.

Например Deals Context, контекст сделок.
Перед тем как попасть на сервис сделок надо авторизоваться, это будет Identity Context.
Одна сущность реального мира может быть представлена в разных контекстах разными сущностями.
Один и тот же человек будет для Deals Context сущностью Seller, а для Identity Context сущностью User.
Эти сущности никак не связаны, у каждой модели свой фокус.

Domain Model и Business Logic должны использовать Ubiquitous Language.
Источник истины не cf, а код.

### Tactical Design

Тактическое проектирование. Это про код.
Описывает набор паттернов, используемых для удобной работы с доменными моделями.
Единственная цель принятия этих паттернов сделать работу с бизнес-логикой простой и эффективной.

Нам абсолютно не обязательно использовать их все, можно подсмотреть какую-то полезную практику, что сможет сделать код лучше.
Можно отмести вообще все, но давайте посмотрим какие из них будут нам выгодны?
Мы можем применять только Strategic Design и выкинуть Tactical Design и в некотором смысле это будет DDD.

В лоб переносить паттерны из C# будет неправильно.
Если мы пишем на Go, то давайте писать код на Go.

Тактические паттерны это просто инструменты, которые могут сделать работу с кодом доменной модели более выразительной.

### Особенности работы с артефактами

У любого объекта в DDD всегда должно быть консистентное состояние.
Поэтому все объекты создаются с помощью конструкторов/фабрик, валидирующих входные данные.
В Go нет геттеров и сеттеров, позволяющих добавить дополнительную валидацию.

### Value Object

- Полностью идентифицируются своими данными
- Не имеют поля ID
- Удобны для строгой типизации данных, например ID
- Очень легко перестараться с количеством типов  
- ~~Не изменяемы~~ (в Go изменяемы)

Пример Value Object: идентификаторы типов, номера телефонов, email

Валидируем только данные пришедшие извне
То что загрузили из БД сразу грузим в поля

Поля экспортируемые, структуры экспортируемые, никаких специальных сложностей и запретов
Пусть возможность привести данные в не консистентное состояния остается на совести пользователя.
Мы дали способ создать валидный объект, методы изменить его и сказали: не трогай.

#### Entity

- Описывает идентифицируемые элементы доменной модели
- Имеет идентификатор
- Может включать в себя Value Object

#### Aggregate 

~ Собирательная сущность, состоящая из Entity и Value Object
- Может включать в себя 
- Другие элементы домена не могут напрямую ссылаться на внутренности агрегата
- Является границей транзакции при изменении данных, агрегат или обновляется целиком, или не обновляется вообще
- Если агрегат не является границей уникальности сущности, то есть entity с одним ID могут присутствовать в нескольких агрегатах, 
  то такая сущность скорее всего сама является агрегатом

Вместо get/set используем методы агрегата с осмысленным неймингом бизнес-процессов
Нет геттеров и сеттеров просто что бы управлять значениями.
Стремление к минимализму.

Все методы агрегата возвращают только error, если изменить состояние состояния агрегата невозможно,
(например ошибка перехода по статусу) то метод должен вернуть ошибку.
Методы доменной модели должны либо выполнить работу, либо вернуть ошибку.

#### Services 

- Domain Services - сервисы содержащие методы для работы с доменом
- Application Services


#### Packages

Пакет ограничивает контекст.
События доменной модели стоит располагать в пакете с самой моделью.
Структура пакетов так же показывает зависимости между моделями.
Хорошая структура пакетов необходима большому приложению.

#### Separated Interface

Выделение какого-либо интерфейса к объекту в отдельный от объекта пакет
В нашем случае интерфейс сервиса объявляется в доменном слое.
Таким образом в доменном слое находимся исчерпывающее описание не только доменной модели приложения,
но и сценарии работы с ней/

#### Application Service

Сервисы в которых обрабатываются различные use cases.
Например: создать заказ, перевести заказ в новый статус и тд.

Примерный флоу работы app service выглядит так:
1. Сущность/Агрегат извлекается из репозитория  
   Пользуемся alias и строгой типизацией
   var id PurchaseID = ...  
   p, err := repo.Find(id)
2. С агрегатом осуществляется какое-то действие вызовом его методов  
   purchase.ApplyOrderTransition(state)
3. Сохраняем агрегат в репозиторий  
   err := repo.Save(p)

#### Repository

Служит для персистентного хранения данных агрегата
Сопоставляет наши программные сущности с постоянным хранилищем

У репозитория обычно всего 2 метода
- Find(id) (aggregate, err)
- Save(aggregate) err

### Сопутствующая архитектура

С точки зрения DDD неважно какую архитектуру выбирать, но есть нюанс.
Нам надо максимально избавить бизнес-логику от сторонних зависимостей.
При использовании сторонних зависимостей мы начинаем использовать терминологию не входящую в Ubiquitous Language и
замусориваем ими бизнес-логику. Теряется фокус.

- Onion
- Event-driven
- Microservices
- CQRS

#### Onion

В качестве оптимальной имеет смысл использовать Onion-архитектуру.
Onion-архитектура позволяет избежать зависимости Domain слоя от остальных.
Зависимости идут снаружи в центр. Внешний слой может зависеть от внутренних, внутренний не может зависеть от внешних.
API & Infrastructure Layer -> Application Layer -> Domain Layer (Core, Business, Model)
API & Infrastructure Layer - получение команд, событий, работа с данными, доменный слой избавляется от зависимостей на эти вещи. Тут так же находятся порты и адапторы.
Application Layer - слой в котором располагаются сценарии, использует доменный слой для реализации use cases.
Domain Layer - доменный слой, находится в центре, не зависит ни от чего. Многие поэтому называют его Core - ядро, то что находится в центре приложения.

#### Event-based

**Event**  
Событие произошедшее в доменной модели приложения.  
В качестве именования используются глаголы в прошедшем времени (например, OrderCreated).
Отличие событий от команд в том, что команда указывает на то, что нужно сделать, а событие уже произошло в прошлом и
только информирует об этом факте.

**Command**
Команда о том, что надо сделать.
В качестве именования используется глагол в повелительном наклонении (например, CreateOrder)

#### CQRS

The Command and Query Responsibility Segregation (CQRS) - шаблон разделения ответственности на команды и запросы.
Разделяет операции чтения и обновления для хранилища данных.
Внедрение CQRS в приложение может максимизировать его производительность, масштабируемость и безопасность.

Что мы выигрываем от разделения?
1. В одном сервисе четко описана бизнес логика доменного сервиса. Код не замусорен разными ручками запросов.
2. С доменного сервиса снимается нагрузка на чтение (в том числе с высоконагруженных ручек)

### Литература

#### Синяя Книга (Blue Book), 2003.

"Domain-Driven Design Tackling Complexity in the Heart of Software", Eric Evans (Эрик Эванс).  
Библия Domain-Driven Design, благодаря этой работе появилось само его определение.
Книга начинается со стратегического проектирования и паттернов Repository, Entity, Aggregate, Value Object,
Domain Services итд.  
До основной части про тактическое проектирование можно не успеть дочитать и упустить суть DDD.
Так же в книге слишком много теории и мало практических примеров.

#### Красная книга (Red Book), 2013

"Implementing Domain-Driven Design", Vaughn Vernon (Вон Вернон).  
Начинается со стратегического проектирования и основ, а потом рассказывает про тактические паттерны и детали реализации.

#### Ромбовидная книга (Rhombus Book), 2015
"Patterns, Principles, and Practices of Domain-Driven Design", Scott Millett (Скотт Миллет).  
Самое полное руководство по DDD с подробными примерами. Содержит все от рекомендаций по стратегическому дизайну
до примера реализации Event Store.
