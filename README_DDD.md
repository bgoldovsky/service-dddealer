# dddealer

---

## Domain-Driven Design

Предметно-ориентированное проектирование — это набор принципов и схем, направленных на создание оптимальных систем объектов. 
Сводится к созданию программных абстракций, которые называются моделью предметной области. 
В эти модели входит бизнес-логика, устанавливающая связь между реальными объектами и кодом и кодом.

Обычно использует сильные стороны ООП, но не подразумевает, что язык его поддерживает.

Domain - предметная область. От предметной области отталкивается проектирование в рамках DDD.
Предметная область — это сущности и действия реального мира, которые надо смоделировать и автоматизировать.
В нашем случае это обычно то что придумал бизнес.

Domain Model - модель предметной области или доменная модель.

Синяя Книга (Blue Book), 2003.  
Термин Domain-Driven Design был предложен Эриком Эвансом (Eric Evans) в книге 
"Domain-Driven Design Tackling Complexity in the Heart of Software". 
Проблема книги в том, что в первой части книги Эванс рассказывает про тактические паттерны (Factory, Repository, Entity, Services).
До второй половины книги мало кто доходит.

Красная книга (Red Book), 2013
"Implementing Domain-Driven Design" книга Вона Вернона (Vaughn Vernon).
Начинается со стратегического проектирования и основ, а потом рассказывает про тактические паттерны и детали реализации.

Особая книга.

- events - что уже произошло OrderCreated
- commands - что надо сделать, глагол в повелительном наклонении (CreateOrder)

Что мы выигрываем?
1. Четко описанная бизнес логика доменного сервиса
2. Снятие с доменного сервиса нагрузки на чтение, в том числе с высоконагруженных ручек

DDD - это всего лишь список рекомендаций, мы можем использовать их по кусочкам.

CQRS про отделение мух от котлет.

Мне кажется, что сообщество Go упускает бенефиты, предлагаемые DDD.
Надеюсь, что некоторые из моих идей убедят вас применить их.

Java/C# ООП языки, а Go нет. Но DDD подходит в обоих случаях, нам необязательно быть в ловушке DDD с этими его инкапсуляцией и наследованием.
Щепотка полиморфизма нам пригодиться, но мы и сейчас ей не брезгуем.
В общем, для того что бы писать красивый код с использованием DDD нам необязательно писать на Go как на Java.

DDD
- Strategic Design.
Это не про код.
Технические специалисты (мы) вместе с доменными экспертами анализируем Domain, предметную область (мы этим регулярно занимаемся на грумингах, кстати).
Определяем Bounded Context, сферу ответственности сервисов и способы их взаимодействия.
Для стратегического проектирования язык и подход к разработке вообще не важен.
Можем писать ООП, можем готовить спагетти, можем даже засунуть весь код в main
  
- Tactical Design
Это про код.
Описывает набор паттернов, используемых для структурирования кода в модели определенные при стратегическом проектировании,
а так же способов работы с этими моделями.
Единственная цель принятия этих паттернов сделать работу с бизнес-логикой простой и эффективной.  
  
Повторюсь, что нам абсолютно не обязательно использовать их все, можно подсмотреть какую-то полезную практику, что сможет сделать код лучше. 
Можно отмести вообще все, но давайте посмотрим какие из них будут нам выгодны?
Мы можем применять только Strategic Design и выкинуть Tactical Design и в некотором смысле это будет DDD.

Стратегический

Валидация при создании Value Object, бизнес-логика проверки
В разных контекстах она может быть разной
При группировке пакет представляет контекст, то есть тут не должно быть email разных контекстов, только админа
Ubiquitous Language гарантирует, что в данном контексте email будет означать только админский или пользовательский, одна трактовка термина.
Для этого артефакты DDD группируются по контексту, проектирование пакетов учитывает границы контекста.

package admin
type Email string
func NewAdminEmail(string) Email {...} // Тут валидация 
...
import "github.com/company/service/admin"
adminEmail, err := admin.NewAdminEmail(me@avito.ru)

События доменной модели стоит располагать в пакете с самой моделью
Пакет ограничивает контекст
Структура пакетов так же показывает зависимости между моделями
Важно максимально исключить прямого импорта одного пакета с моделью на другой, задействуем третий
Хорошая структура пакетов необходима большому приложению
customer/
-> customer.go
-> events/     // События стоит вынести в отдельный пакет, так как они будут импортированы третьей стороной
    -> events.go
admin/
-> admin.go
-> events/
    -> events.go

Upstream/Downstream коммуникация между системами и командами

Тактический

В лоб переносить паттерны из C# будет неправильно. 
Если мы пишем на Go, то давайте писать код на Go.



### Особенности работы с артефактами

У любого объекта в DDD всегда должно быть консистентное состояние.
Поэтому все объекты создаются с помощью конструкторов/фабрик, валидирующих входные данные.


Value Object (Для нас это Phone, Address и т.д.)
Валидируем данные в конструкторе?

- Удобны для типизации данных, гарантируют что orderID не будет передан вместо purchaseID
- Очень легко перестараться с количеством, сделав Value Object все от денег до размеров. Это усложнит код.





### Value Object  
- Полностью идентифицируются своими данными
- Не имеют поля ID
- ~~Не изменяемы~~

Пример Value Object: идентификаторы типов, номера телефонов, email  

Value Object очень удобны в качестве идентификаторов типов и достижения более строгой типизации


У любого объекта в DDD всегда должно быть консистентное состояние
Always valid state
Валидация на уровне:
* Handler
* Model
В Go нет геттеров и сеттеров, позволяющих добавить дополнительную валидацию.
Не жили хорошо, нечего начинать. Но попробуем найти промежуточное решение не отклоняясь от идиом языка.


Можно помещать каждый value type в отдельный файл, если они большие

1. Используем конструкторы (фабричные функции, если быть совсем честными)
Тогда валидацию можно будет добавить в них
package tab
type Tab struct {
    Title string
}
func New(title string) (*Tab, error) { 
   switch l:=len(title) {
   case l < 1:
        return nil, errors.New("could not use title less then 1 char")
   case l > 50:
        return nil, errors.New("could not use title greater then 50 char")
   }
   return &Tab{Title: title}
}
...
t, err := tab.New("hello!")
if err != nil {
   panic(err)
}   
// Из-за отсутствия setter мы все равно можем установить invalid state  
t.Title = ""   
   
Валидируем только данные пришедшие извне
То что загрузили из БД сразу грузим в поля

Поля экспортируемые, структуры экспортируемые, никаких специальных сложностей и запретов

Интерфейс агрегата
Интерфейс события
   
Копая себе могилу мы можем начать механизмами экспортирования закрывать поля и типы,
превращая код в Java-like
Пусть возможность привести данные в не консистентное состояния остается на совести пользователя. 
Коллеги не дураки, за время работы в Авито я привык, что даже заметно умнее.
Мы дали способ создать валидный объект, методы изменить его и сказали: не трогай.
Наша совесть чиста.

package tab

type Title string 

func NewTitle(title string) (*Tab, error) {
    switch l:=len(title) {
    case l < 1:
        return nil, errors.New("title: could not use title less then 1 char")
    case l > 50:
        return nil, errors.New("title: could not use title greater then 50 char")
    default:
        return Title(title), nil
    }
}

func (t *Title) String() string {
    return string(t)
}

// Для Value типа необходима операция сравнения, так как она его идентифицирует
// Опционально делаем то что пригодится: Equal, Greater, Less
func (t *Title) Equals() bool {
    return t.String()
}

Валидации не надо дублировать, просто маппим в Handler данные в Value Type и если при вызове конструктора  возникнет ошибка,
то вернем ее с кодом 400, Bad Request

#### Repository

Сопоставляет наши программные сущности с постоянным хранилищем 
Ошибки надо хранить там же где интерфейсы, что бы в коде сервисов легко сопоставить их

var (
    ErrRepoNextID := errors.New("tab: couldn't return next id")
    ...
)

type Repo interface {
    NextID() (ID, error)
    Find(ID) (*Tab, error)
    Save(*Tab) error
}

Ошибки используем в конкретной реализации.
Возвращать конкретную ошибку и детали для конкретной реализации

func (r *PgRepo) NextID() (ID, error) {
    ...
    return fmt.Errorf("%v: %s", tab.ErrRepoNextID, "details here")
}

Если репозиторий часть доменной модели и его контракта, то он должен лежать в domain 
и может иметь специфические методы, реализующие часть доменной логики.
err := repo.GetActiveOrders()
val, err := repo.GetSomethingStrange()

Примерная структура

internal/  
    app/  
    repo/
        customer/
            /customer.go // Тут конкретная реализация репозитория
    customer/  
        -> customer.go  
        -> repo.go // Тут интерфейс репозитория
        -> events/     // События стоит вынести в отдельный пакет, так как они будут импортированы третьей стороной
            -> events.go

## 

"Немного есть вещей менее логичных, чем бизнес-логика"  
Мартин Фаулер

Какая-то часть реального мира, бизнес-процессы превращаются в код. Построение программной модели.
Сложности:
- Сложность реального мира (то есть самой бизнес-модели)
- Сложность реализации модели в виде кода

Основная цель DDD - это борьба со сложностью бизнес-процессов и их реализации в коде.
DDD набор подходов, который помогает писать код приложений (сервисов) со сложной предметной областью.

Если нам нужен простой CRUD сервис (которые мы больше стараемся не плодить), то DDD это излишество.
В системах с простой бизнес-логикой DDD излишество, оно только усложнит код.

DDD включает в себя:
- Стратегическое проектирование
- Тактические паттерны  
- Подходы к архитектуре
- Взаимодействие между людьми

Go язык лаконичный, он не любит многословного Java-style нейминга вроде 
order.ApplyItAllWithHappyAvitoNow()

Ключевые концепции DDD:
- Domain
- Ubiquitous Language (общий язык домена)
- Шаблоны проектирования:
  * Entity
  * Value Objects
  * Aggregate
  * Repository
  * Service
    
Артефакты доменной модели

Entity (Для нас это Purchase, Order и тд)
Отвечает за целостность и валидацию своих данных
Валидируем данные в конструкторе
- Описывает идентифицируемые элементы доменной модели
- Имеет идентификатор
- Может включать в себя Value Object


Aggregate 
~ Собирательная сущность, состоящая из Entity и Value Object
- Может включать в себя 
- Другие элементы домена не могут напрямую ссылаться на внутренности агрегата
- Является границей транзакции при изменении данных, агрегат или обновляется целиком, или не обновляется вообще
- Если агрегат не является границей уникальности сущности, то есть entity с одним ID могут присутствовать в нескольких агрегатах, 
  то такая сущность скорее всего сама является агрегатом

Вместо get/set используем методы агрегата с осмысленным неймингом бизнес-процессов
Нет геттеров и сеттеров просто что бы управлять значениями.
Стремление к минимализму.

В конструкторах только обязательные свойства без которых объект не может существовать.
Валидация в конструкторе?

- Domain Services
- Application Services

Анемичная модель — хранит данные, отражает связи, но не содержит бизнес-логики.

Все методы агрегата возвращают только error, если изменить состояние состояния агрегата невозможно,
(например ошибка перехода по статусу) то метод должен вернуть ошибку.
Методы доменной модели должны либо выполнить работу, либо вернуть ошибку.

Repository
- В доменном слое описываются интерфейсом
- Объекты рне зависят от структуры БД
- Реализация не важна

Гидраторы — объекты для заполнения доменной модели данными из репозитория.
Сначала данные выгребаются в гидраторы, потом из гидраторов заполняется доменная модель.
Использования гидраторов можно избежать, если пользоваться Event Sourcing.

Domain Services
- Сервисы содержащие методы для работы с доменом

Domain Events
В агрегате находится массив событий, заполняющийся при любом изменении состояния агрегата.
Аутбоксинг.

## Сущности DDD

Domain - глобальная предметная область, которой бизнес зарабатывает деньги. 
Domain - классифайд.

Subdomain - части предметной области, обладающие сильной связанностью, которые на более крупном уровне между собой взаимодействуют.
Часто Subdomain в контексте проекта сокращают просто до Domain, потому что глобально видеть бизнес всей компании нам не так уж и надо.
Subdomain - доставка

С точки зрения DDD Subdomain делятся на 3 типа
- Core - конкурентное преимущество компании, то на чем она зарабатывает деньги, то чем она отличается от конкурентов.
  Для нас это доска объявлений с возможностью покупать разные айтемы.
- Supporting - тоже то что используется для зарабатывания денег, но не то без чего нельзя.
  На Supporting бросается меньше сил, чем на Core, но он все равно очень важен.
  Для нас это доставка. Классифайд может существовать без доставки, но это будет не так удобно, выгодно и безопасно.
- Generic - типовая бизнес-задача, которую можно автоматизировать готовыми продуктами, не требует самостоятельной реализации, лучше использовать 3rd-party решение.
  Для нас это например ведение бухгалтерии в 1c, мы не будем писать для Авито свою систему учета.

Bounded Context - находится рядом с domain.
Subdomain - кусочек бизнеса, кусочек реального мира. Понятие пространства постановки задачи.
Bounded context - контекст, который ограничивает доменную модель и ubiquitous language. Понятия пространства решения.
В процессе разработки происходит маппинг Subdomain на Bounded Context.
Например ребята из логистики придумали как сделать пикап для мерчантов маркетплейса, а для нас это стало сервисом marketplace registry и proxy-api
Доставка -> Custom Applications

Как выбрать правильный размер Bounded Context?
Bounded Context должен быть таким, что бы ubiquitous language был полным и однозначным.
1 Bounded Context = 1 Subdomain
1 Bounded Context = 1 Microservice (На самом деле они будут уже не микро, но это даже хорошо, нам не нужно еще 100 CRUD-сервисов)

Если мы хотим делать совсем каноничные микросервисы, то это скорее всего будет
1 Aggregate = 1 Microservice (Количество связей между сервисами увеличивается)

Один домен мапиться на один контекст, но это идеальная ситуация, необязательно должно быть так.

Нормально, что в одном сервисе несколько агрегатов, например мы работаем с заказами и с ивентами.

## Стратегическое проектирование

Domain Experts - доменные эксперты, люди понимающие, как работают те бизнес-процессы, которые предстоит моделировать.

Технические специалисты — разработчики, архитекторы, те кто непосредственно занимается реализацией приложения.

Обычно между доменными экспертами и техническими специалистами стена и продукт менеджер. 
В идеале они должны постоянно работать напрямую и синхронизироваться в достижении целей.

Доменные эксперты часто опускают очевидные для них детали о которых разработчик никогда не подумает.
Технические специалисты должны вытащить из доменных экспертов следующие:
- Знание о модели. Задаем много дополнительных вопросов, прорабатываем каждое действие и аспект, которые станут методами и полями.
- Общие и частные случаи
- Отсечь лишнее, не реализовываем ту часть предметной области, которая не нужна нашей модели
- Обращать внимание на детали

Избегаем сложных формул и неочевидных конструкций.
Отличный пример старый калькулятор
price := ((item * q)/1000) * 0.8 + x + m[prov]/1000

1. Сущность/Агрегат извлекается из репозитория  
   Пользуемся alias и строгой типизацией
   var id PurchaseID = ...  
   p, err := repo.Find(id)  
2. С агрегатом осуществляется какое-то действие вызовом его методов  
   purchase.ApplyOrderTransition(state)
3. Сохраняем агрегат в репозиторий  
   err := repo.Save(p)
   
У репозитория всего 2 метода  
- Find(id) (aggregate, err)
- Save(aggregate) err

Слои приложения
- services
- model
- repo


### Ubiquitous Language
Общение между участниками проекта формирует Общий язык (Ubiquitous Language).
Набор терминов, применяемый в модели предметной области для ее описания.
Все участники проекта общаются на нем. Обсуждения происходят только в терминах единого языка.
Все артефакты от ТЗ и задач до кода только в терминах единого языка.

Выбираем один английский термин для одного объекта или события бизнес-логики.
Многие ошибки происходят именно из-за плохого перевода или его разночтений.
Многозначных терминов в бизнес-логике лучше избегать: транзакция, политика, запрос.

Контроль единого языка на ревью.

В коде фигурируют человеческие слова и понятная терминология, в теории его может прочесть даже менеджер.
Новые участники команды смогут проще вникать в суть бизнес-процессов.
Сервисы единообразны, просты для понимания

1. Берем сценарий на автоматизацию
2. Строим доменную модель

### Bounded Context

Доменная модель не может быть безграничной и охватывать все.
Тогда она станет размытой и потеряет фокус.

Domain Model и Ubiquitous Language ограничены контекстом (Bounded Context).
Ограничивает доменную модель таким образом, что бы все понятия в нем были однозначными и все участники проекта понимали, 
о чем идет речь. У каждого понятия понятная роль и понятное значение.

Например Deals Context, контекст сделок.
Перед тем как попасть на сервис сделок надо авторизоваться, это будет Identity Context.
Одна сущность реального мира может быть представлена в разных контекстах разными сущностями.
Один и тот же человек будет для Deals Context сущностью Seller, а для Identity Context сущностью User.
Эти сущности никак не связаны, у каждой модели свой фокус.

Domain Model и Business Logic должны использовать Ubiquitous Language.
Источник истины не cf, а код.

### Архитектура и управление зависимостями

С точки зрения DDD неважно какую архитектуру выбирать, но есть нюанс.
Нам надо максимально избавить бизнес-логику от сторонних зависимостей. 
При использовании сторонних зависимостей мы начинаем использовать терминологию не входящую в Ubiquitous Language и 
замусориваем ими бизнес-логику. Теряется фокус.

Onion-архитектура позволяет избежать зависимости Domain слоя от остальных.
Зависимости идут снаружи в центр. Внешний слой может зависеть от внутренних, внутренний не может зависеть от внешних.
API & Infrastructure Layer -> Application Layer -> Domain Layer (Core, Business, Model)
API & Infrastructure Layer - получение команд, событий, работа с данными, доменный слой избавляется от зависимостей на эти вещи. Тут так же находятся порты и адапторы.
Application Layer - слой в котором располагаются сценарии, использует доменный слой для реализации use cases.
Domain Layer - доменный слой, находится в центре, не зависит ни от чего. Многие поэтому называют его Core - ядро, то что находится в центре приложения.

Можно использовать Onion или Hexagonal архитектуру.

DDD:
- Event-driven
- Microservices
- Layers
- CQRS

## Тактическое проектирование

Тактические паттерны, не в них суть, но это отличные инструменты

### Separated Interface

Интерфейс сервиса, используемого в доменной логике (например репозитории) объявляется в доменном слое.
Детали их реализации не являются бизнес-логикой, но сам факт их существования и вызова являются частью бизнес-логики.
Интерфейс репозитория в доменном слое, а реализация в инфраструктурном.
type interface Repository {
    Find()
    Save()
    GetWithLock() // Кастомный метод, относиться к доменной логике, поэтому интерфейс принадлежит доменному слою
}

Основная цель не в нейминге слоев, а в том, что бы избавить доменный слой от сторонних зависимости и внешней терминологии.